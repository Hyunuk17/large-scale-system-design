> **15장. 구글 드라이브 설계**

<details>
  <summary><b>문제 이해 및 설계 범위 확정</b></summary>  
  
  ---
  
  ## 1단계: 문제 이해 및 설계 범위 확정
  
  ### 클라우드 저장소 서비스
  
  - 구글 드라이브(Google Drive)
  - 드롭박스(Dropbox)
  - 마이크로소프트 원드라이브(Microsoft OneDrive)
  - 애플 아이클라우드(Apple iCloud)
  
  ### 구글 드라이브
  
  - 파일 저장 및 동기화 서비스
  - 문서, 사진, 비디오, 기타 파일을 클라우드에 보관
  - 컴퓨터, 스마트폰, 태블릿 등 어떤 단말에서도 이용 가능해야 함
  - 저장된 파일은 친구, 가족, 동료들과 손쉽게 공유할 수 있어야 함
  
  ### 요구사항 분석
  
  - **Q.** 가장 중요하게 지원해야 할 기능들은?
  - **A.** 파일 업로드/다운로드, 파일 동기화, 알림(Notification)
  - **Q.** 모바일 앱과 웹 앱을 모두 지원해야 하는가?
  - **A.** 둘 다 지원해야 함
  - **Q.** 파일을 암호화해야 하는가?
  - **A.** 암호화해야 함
  - **Q.** 파일 크기에 제한이 있는가?
  - **A.** 10GB 제한
  - **Q.** 사용자의 수는?
  - **A.** 일간 능동 사용자(DAU) 기준으로 천만(10Million)명
  
  ### 기능적 요구사항
  
  - **파일 추가**
      - 가장 쉬운 구현 방법은 파일을 구글 드라이브 안으로 떨구는(Drag-and-Drop) 것
  - **파일 다운로드**
  - **파일 동기화**
      - 한 단말에서 파일을 추가하면 다른 단말에도 자동으로 동기화
  - **파일 갱신 이력 조회(Reversion History)**
  - **파일 공유**
  - **알림**
      - 파일이 편집되거나 삭제되거나 새롭게 공유되었을 때 알림 표시
  
  ### 비기능적 요구사항
  
  - **안정성**
      - 저장소 시스템에서 안정성은 매우 중요한 요소
      - 데이터 손실이 발생해서는 안됨
  - **빠른 동기화 속도**
      - 동기화에 시간이 너무 많이 걸리면, 사용자는 인내심을 잃고 제품을 더 이상 사용하지 않음
  - **네트워크 대역폭**
      - 네트워크 대역폭을 불필요하게 많이 소모할수록 사용자는 선호하지 않음
      - 특히, 모바일 데이터 플랜을 사용하는 경우 더욱 중요
  - **규모 확장성**
      - 아주 많은 양의 트래픽을 처리할 수 있는 시스템이어야 함
  - **높은 가용성**
      - 일부 서버에 장애 발생, 느려짐, 네트워크 일부가 끊기는 경우에도 시스템은 계속 사용 가능
  
  ### 개략적 추정치
  
  - 가입 사용자 5천만(50million)명, 천만명의 DAU 사용자 가정
  - 모든 사용자에게 10GB의 무료 저장공간 할당
  - 매일 각 사용자가 평균 2개의 파일을 업로드 가정, 각 파일의 평균 크기는 500KB
  - 읽기:쓰기 비율은 1:1
  - 필요한 저장공간 총량 : $5천만 \ 사용자 * 10GB * 500페타바이트(Petabyte)$
  - 업로드 API OPS : $1천만 \ 사용자 * 2회 \ 업로드/24시간/3600초 = 약 240$
  - 최대 OPS : $QPS * 2 = 480$
  
  ---

  </details>
  
<details>
  <summary><b>개략적 설계안 제시 및 동의 구하기</b></summary>
  
  ---
  
  ## 2단계: 개략적 설계안 제시 및 동의 구하기
  
  ### 점진적 설계: 서버 1대
  
  - **웹 서버** : 파일을 올리고 다운로드하는 과정을 처리
  - **데이터베이스** : 사용자 데이터, 로그인 정보, 파일 정보 등의 메타데이터 보관
  - **저장소 시스템** : 파일을 정장, 1TB 공간 사용
  
<img src="https://github.com/user-attachments/assets/42c67d7c-426f-4db3-915c-ea139c26e965" width="400px"/>

  - **아파치(Apache) 웹 서버 설치**
  - **MySQL 데이터베이스 설치**
  - **drive/ 디렉터리 준비**
      - 내부에 **네임스페이스(Namespace)**라고 불리는 하위 디렉터리들을 가짐
      - 각 네임스페이스 안에는 특성 사용자가 올린 파일 보관
      - 각 파일과 폴더의 상대 경로를 네임스페이스와 결합하여 **유일하게 식별**
  
  ### API
  
  - **1️⃣ 파일 업로드 API**
      - **단순 업로드**
          - 파일 크기가 작을 때 사용
      - **이어 올리기(Resumable Upload)**
          - 파일 사이즈가 크고, 네트워크 문제로 중단 가능성이 높을 때 사용
          - ex) `https://api/example/com/files/upload?uploadType=resumable`
          - **인자**
              - `uploadType=resumable`
              - `data` : 업로드할 로컬 파일
          - **동작**
              - 이어 올리기 URL을 받기 위한 최초 요청 전송
              - 데이터를 업로드하고 업로드 상태 모니터링
              - 업로드에 장애가 발생하면 장애 발생시점부터 업로드를 재시작
  - **2️⃣ 파일 다운로드 API**
      - ex) `https://api.example.com/files/download`
      - **인자**
          
          ```jsx
          {
            "path": "/recipes/soup/best_soup.txt"
          }
          ```
          
          - `path` : 다운로드할 파일의 경로
  - **3️⃣ 파일 갱신 히스토리 제공 API**
      - ex) `https://api.example.com/files/list_revisions`
      - **인자**
          
          ```jsx
          {
            "path": "recipes/soup/best_soup.txt",
            "limit": 20
          }
          ```
          
          - `path` : 갱신 히스토리를 가져올 파일의 경로
          - `limit` : 히스토리 길이의 최대치
  
  ### 한 대 서버의 제약 극복
  
  - **파일 시스템 공간 부족**
      
    <img src="https://github.com/user-attachments/assets/d207396c-6979-4239-b2d1-cd6390d3d840" width="400px"/>

      - 파일 시스템의 여유 공간이 10MB 남음
      - 사용자는 더 이상 파일을 올릴 수 없음
  - **데이터 샤딩(Sharding)**
      
    <img src="https://github.com/user-attachments/assets/1b1f23d7-e4ef-475d-9b90-d724576148fc" width="400px"/>

      - `user_id`를 기준으로 샤딩
  - **S3 사용**
      - Netflix, Airbnb : 저장소로 Amazon S3 사용
      - **Amazon S3(Simple Storage Service)**
          - 객체 저장소 서비스
          - 업계 최고 수준의 규모 확장성, 가용성, 보안 성능 제공
          - **다중화 지원**
              
            <img src="https://github.com/user-attachments/assets/c3cc0ac6-45c0-4289-9d7b-11f2d32efad3" width="400px"/>

              - 같은 지역 내부 다중화, **여러 지역에 걸쳐 다중화(가용성 보장에 우월)**
              - **AWS 서비스 지역(Region)** : Amazon AWS가 데이터 센터를 운영하는 지리적 영역
              - **S3 버킷(Bucket)** : 파일 시스템의 폴더와 같은 저장공간
  
  ### 개선된 설계안
  
  <img src="https://github.com/user-attachments/assets/b71fb026-e058-4070-9572-40516de88d30" width="400px"/>

  - **로드밸런서**
      - 네트워크 트래픽을 고르게 분산
      - 특정 웹 서버에 장애 발생 시 자동 서버 우회 기능을 제공
  - **웹 서버**
      - 로드밸런서를 추가하면, 더 많은 웹 서버를 손쉽게 추가할 수 있음
      - 트래픽이 폭증하는 경우 쉽게 대응 가능
  - **메타데이터 데이터베이스**
      - 데이터베이스를 파일 저장 서버에서 분리, **SPOF(Single Point Of Failure) 회피**
  - **파일 저장소**
      - S3를 파일 저장소로 사용
      - 가용성과 데이터 무손실을 보장하기 위해 두 개 이상의 지역에 데이터를 다중화
  
  ### 동기화 충돌
  
  - 두 명 이상의 사용자가 같은 파일이나 폴더를 **동시에 업데이트**
  - **충돌 해소 전략**
      
    <img src="https://github.com/user-attachments/assets/6acbfd32-b165-435a-9df0-8bef1d018c07" width="400px"/>

      - 먼저 처리되는 변경은 성공
      - 나중에 처리되는 변경은 충돌이 발생한 것으로 표시 : **동기화 충볼 오류**
      
    <img src="https://github.com/user-attachments/assets/a5e21d8b-64df-4406-82dc-27df49816996" width="400px"/>

      - 오류가 발생한 시점에 **같은 파일의 2가지 버전이 존재** : 로컬 사본(Local Copy), 최신 버전
      - 사용자는 두 파일을 하나로 합칠지, 아니면 둘 중 하나를 다른 파일로 대체할지 결정 필요
  
  ### 개략적 설계안
  
  <img src="https://github.com/user-attachments/assets/514a4399-3463-455d-a060-041f7189b20f" width="400px"/>

  - 1️⃣ **사용자 단말**
      - 사용자가 이용하는 웹 브라우저나 모바일 앱 등의 클라이언트
  - 2️⃣ **블록 저장소 서버(Block Server)**
      - 파일 블록을 클라우드 저장소에 업로드하는 서버
      - 블록 수준 저장소(Block-Level Storage) : 클라우드 환경에서 데이터 파일을 저장하는 기술
      - **블록(BlocK)**
          - 파일을 여러 블록(BlocK)으로 나누어 저장, ex) Dropbox 4MB
          - 각 블록에는 고유한 **해시(Hash)값**이 할당
          - 해시값은 메타데이터 데이터베이스에 저장
          - 각 블록은 독립적인 객체로 취급, **클라우드 저장소 시스템(ex S3)에 저장**
          - 파일을 재구성하기 위해 블록들을 **원래 순서대로 결합**하여 사용
  - 3️⃣ **클라우드 저장소**
      - 블록 단위로 나누어진 파일을 보관
  - 4️⃣ **아카이빙 저장소(Cold Storage)**
      - 오랫동안 사용되지 않은 **비활성(Inactive) 데이터를 저장**하기 위한 컴퓨터 시스템
  - 5️⃣ **로드밸런서**
      - 요청을 모든 API 서버에 고르게 분산하는 역할
  - 6️⃣ **API 서버**
      - 파일 업로드 외에 모든 것을 담당하는 서버
      - ex) 사용자 인증, 사용자 프로파일 관리, 파일 메타데이터 갱신 등
  - 7️⃣ **메타데이터 데이터베이스**
      - **메타데이터 정보**를 관리, ex) 사용자, 파일, 블록, 버전 등
      - 실제 파일은 클라우드에 보관됨
  - 8️⃣ **메타데이터 캐시**
      - 성능을 높이기 위해 사용
      - 자주 쓰이는 메타데이터를 캐싱
  - 9️⃣ **알림 서비스**
      - 특정 이벤트가 발생했음을 클라이언트에게 알리기 위해 사용하는 시스템
      - 발행(Publish)/구독(Subscribe) 프로토콜 기반
      - ex) 파일 추가/편집/삭제 알림
  - 🔟 **오프라인 사용자 백업 큐(Offine Backup Queue)**
      - 클라이언트가 접속 중이 아니라서 파일의 최신 상태를 확인할 수 없는 경우
      - 해당 정보를 큐에 두어, 나중에 **클라이언트가 접속했을 때 동기화**
  
  ---
  
  </details>
<details>
  <summary><b>상세 설계</b></summary>
  
  ---
  
  ## 3단계: 상세 설계
  
  ### 블록 저장소 서버
  
  - **네트워크 대역폭 최적화**
      - 업데이트 시 매번 전체 파일을 서버로 보내면 **네트워크 낭비.** ex) 정기적으로 갱신되는 큰 파일
      - 1️⃣ **델타 동기화(Delta Sync)**
          - 파일이 수정되면 전체 파일 수정 대신, **수정이 일어난 블록(Block)만 동기화**
      - **2️⃣ 압축(Compression)**
          - **블록 단위로 압축**해 두면 데이터 크기를 많이 줄일 수 있음
          - 파일 유형에 따라 압축 알고리즘 선택
          - ex) 텍스트 파일 : `gzip`, `bzip2`, 이미지나 비디오 파일 : 다른 압축 알고리즘
  - **블록 저장소 서버**
      - **파일 업로드**에 관련한 작업을 처리하는 컴포넌트
          
        <img src="https://github.com/user-attachments/assets/079f341c-8e9f-4662-b609-ceaaf58f9171" width="400px"/>

          - 클라이언트의 파일을 **블록 단위로 분할(클라이언트가 분할한 상태로 전송하는 경우 있음)**
          - 각 블록에 **압축 알고리즘 적용**
          - 각 블록 **암호화**
          - **클라우드 저장소**로 전송
      - **델타 동기화 전략**
          
        <img src="https://github.com/user-attachments/assets/aa0661e4-e421-4c29-b018-7bc6613aeb24" width="400px"/>

          - **수정된 블록**을 클라우드 저장소에 업로드
          - 전체 파일을 저장소 시스템으로 보내지 않음 : **네트워크 대역폭 사용량 절감**
  
  ### 높은 일관성 요구사항
  
  - **강한 일관성(Strong Consistency) 모델**
      - 같은 파일이 단말이나 사용자에 따라 **다르게 보이는 것을 허용하지 않음(일관성)**
      - **메타데이터 캐시**와 **데이터베이스 계층**에도 같은 원칙이 적용되어야 함
      - 메모리 캐시
          - **최종 일관성(Eventual Consistency) 모델 :** 시간이 지남에 따라 최종적으로 일관성 유지
  - **강한 일관성 달성 조건**
      - 1️⃣ 캐시에 보관된 사본과 데이터베이스에 있는 원본(Master)이 일치
      - 2️⃣ 데이터베이스에 보관된 **원본에 변경이 발생**하면 캐시에 있는 **사본을 무효화**
  - **강한 일관성 구현**
      - **RDB(설계안 채택)**
          - ACID(Atomicity, Consistency, Isloaltion, Durability)를 보장
          - 강한 일관성 기본으로 보장
      - **NoSQL**
          - 강한 일관성을 기본으로 지원하지 않음
          - 동기화 로직 안에 작성하여 넣어야 함
  
  ### 메타데이터 데이터베이스
  
  - **데이터베이스 스키마 설계안**
      
    <img src="https://github.com/user-attachments/assets/740589a8-0bad-4252-9114-df545721806f" width="400px"/>

      - **`user`**
          - 사용자에 관계된 기본적인 정보
          - ex) 이름, 이메일, 프로페일 사진 등
      - **`device`**
          - 단말 정보 보관
          - push_id : 모바일 푸시 알림을 보내고 받기 위한 ID
          - 한 사용자가 **여러 대의 단말**을 가질 수 있음, **1:N**
      - **`namespace`**
          - 사용자의 루트 디렉터리 정보 보관
      - **`file`**
          - 파일의 최신 정보가 보관
      - **`file_version`**
          - 파일의 갱신 이력 보관
          - 갱신 이력이 **훼손되는 것을 방지**하기 위해, 레코드는 모두 읽기 전용(**Read Only**)
      - **`block`**
          - 파일 블록에 대한 정보를 보관
          - 특정 버전의 파일은 파일 블록을 **올바른 순서로 조합**하기만 하면 복원해 낼 수 있음
  
  ### 업로드 절차
  
  - **파일 업로드 시퀀스 다이어그램**
      
    <img src="https://github.com/user-attachments/assets/e6fa5da4-35f2-42fe-b1c6-9e6b769fc894" width="400px"/>

      - **두 개 요청이 병렬적으로 전송**
          - 1️⃣ **첫 번째 요청 : 파일 메타데이터를 추가**
              1. `클라이언트 1`이 새 파일의 **메타데이터를 추가**하기 위한 요청 전송
              2. 새 파일의 **메타데이터를 DB에 저장**, 업로드 상태를 **대기중(Pending)**으로 변경
              3. 새 파일이 추가되었음을 **알림 서비스에 통지**
              4. 알림 서비스는 관련된 클라이언트(`클라이언트 2`)에게 파일이 업로드되고 있음을 알림
          - 2️⃣ **두 번째 요청 : 파일을 클라우드 저장소로 업로드(& 파일 수정)**
              1. `클라이언트 1`이 파일을 **블록 저장소 서버**에 업로드
              2. 블록 저장소 서버는 파일을 **블록 단위 분할 후 압축/암호화**, 클라우드 저장소에 전송
              3. **업로드가 끝나면** 클라우드 저장소는 **완료 콜백(Callback)을 호출**, API 서버로 전송
              4. API 서버는 메타데이터 DB에 기록된 해당 파일의 **상태를 완료(Uplaoded)로 변경**
              5. 알림 서비스에 파일 업로드가 끝났음을 통지
              6. 알림 서비스는 관련된 클라이언트(`클라이언트 2`)에게 파일 업로드 완료를 알림
  
  ### 다운로드 절차
  
  - **파일 다운로드**
      - 파일이 새로 추가되거나 편집되면 자동으로 시작
      - 다른 클라이언트가 파일을 편집/추가해도 **원래 클라이언트가 감지**할 수 있어야 함
  - **파일 다운로드 감지**
      - 1️⃣ **`클라이언트 A`가 접속 중**이고, 다른 클라이언트가 파일을 변경
          - 알림 서비스가 `클라이언트 A`에게 변경이 발생했으니 **새 버전을 참조**할 것을 알림
      - `2️⃣ **클라이언트 A`가 네트워크에 연결되지 않은 상태**
          - 데이터는 캐시에 보관
          - 해당 `클라이언트 A`의 상태가 접속 중으로 변경되면, 그 때 새 버전을 참조
  - **파일 변경 시 재구성 흐름**
      - API 서버를 통해 메타데이터를 새로 가져감
      - 블록들을 다운받아 파일을 재구성
      
    <img src="https://github.com/user-attachments/assets/213c763a-2711-40fc-b8f9-8bc9416859f1" width="400px"/>

      1. 알림 서비스가 `클라이언트 2`에게 **누군가가 파일을 변경**했음을 알림
      2. 알림을 확인한 `클라이언트 2`는 **새로운 메타데이터를 요청**
      3. **API 서버**는 메타데이터 데이터베이스에게 새 메타데이터 요청
      4. API 서버에게 새 메타데이터가 반환
      5. `클라이언트 2`에게 새 메타데이터 반환
      6. `클라이언트 2`는 새 메타데이터를 받는 즉시, **블록 다운로드 요청 전송**
      7. **블록 저장소 서버**는 클라우드 저장소에서 **블록 다운로드**
      8. **클라우드 저장소**는 블록 서버에 **요청된 블록 반환**
      9. 블록 저장소 서버는 `클라이언트 2`에게 요청된 블록 반환
      10. `클라이언트 2`는 전송된 블록으로 **파일 재구성**
  
  ### 알림 서비스
  
  - **파일의 일관성 유지**
      - 클라이언트는 로컬에서 파일이 수정되었음을 감지
      - 다른 클라이언트에게 파일 수정 사실을 알려 충돌 가능성을 줄여야 함 : **알림 서비스 사용**
  - **알림 서비스**
      - 이벤트 데이터를 여러 클라이언트들로 보내는 서비스
      - **롱 폴링(Long Polling)** : 드롭박스(Dropbox)가 채택한 방식
      - **웹소켓(WebSocket)** : 클라이언트와 서버 사이에 통신 채널(Channel) 제공, 양방향 통신
  - **롱 폴링**
      - **동작 방식: 알림 서버와 롱 폴링용 연결 유지(평소에도 유지)**
          - 1️⃣ 클라이언트는 롱 폴링 연결을 유지하여 실시간으로 변경 사항을 감지
          - 2️⃣서버가 특정 파일에 대한 **변경을 감지**하면, **해당 롱 폴링 연결을 끊음(변경 알림 전송)**
          - 3️⃣ 클라이언트는 알림을 받고 즉시 메타데이터 서버에서 **파일의 최신 내역을 다운로드**
          - 4️⃣ 다운로드 작업이 **종료/연결 타임아웃 시간에 도달**한 경우 **롱 폴링 연결을 복원/유지**
          - 5️⃣ 클라이언트는 다시 실시간으로 변경 사항을 감지
      - **단방향 통신**
          - 서버는 파일이 변경된 사실을 클라이언트에게 알림
          - 알림 서비스와의 양방향 통신이 필요하지 않음
          - ex) 채팅 서비스(양방향), 알림 서비스(단방향)
      - **알림의 양이 적음**
          - 구글 드라이브(Google Drive)의 경우, 알림을 보낼 일이 그렇게 자주 발생하지 않음
          - 알림을 보내는 경우에도, 단시간에 많은 양의 데이터를 보낼 일이 없음
          - 실시간 양방향 통신(ex 채팅)의 경우 웹소켓을 이용
  
  ### 저장소 공간 절약
  
  - **파일 백업**
      - 여러 버전을 여러 데이터센터에 보관
          - 파일 갱신 이력 보존
          - 파일의 안정성 보장
      - 모든 버전을 자주 백업하는 것은 너무 많은 저장용량 소모
  - **비용 절감 전략**
      - **1️⃣ 중복 제거(De-dupe, Dedeuplication)**
          - **중복된 파일 블록(Block)**을 계정 차원에서 제거
          - **해시(Hash)값을 비교**하여 두 블록이 같은 블록인지 판단
      - **2️⃣ 지능적 백업 전략 도입**
          - **한도 설정**
              - 보관해야 하는 파일 버전 **개수의 상한을 제한**
              - 상한에 도달하면 가장 오래된 버전을 버림
          - **중요한 버전만 보관**
              - 불필요한 버전과 사본이 만들어지지 않도록 중요한 것만 골라내는 알고리즘 작성
              - ex) 불필요한 버전 : 편집 중인 문서 업데이트마다 새로운 버전 생성
      - **3️⃣ 자주 쓰이지 않는 데이터 이동**
          - 오랫동안 사용되지 않은 데이터를 **아카이빙 저장소(Cold Storage)에 보관**
          - **Amazon S3 글래시어(Glacier)**
              - 아카이빙 저장소, S3보다 이용료가 훨신 저렴
              - 일일 검색량에 제한 존재
              - 데이터를 마음대로 삭제할 수 없음
              - ex) 몇달 혹은 수년간 이용되지 않은 데이터
  
  ### 장애 처리
  
  - 1️⃣ **로드밸런서 장애**
      - 로드밸런서에 장애 발생 시, **부(Secondary) 로드밸런서가 활성화**되어 트래픽을 이어받음
      - 로드밸런서끼리는 **박동(Heartbeat) 신호**를 주기적으로 보내 상태를 모니터링 : **Heath Check**
      - 일정 시간동안 박동 신호에 응답하지 않은 로드밸런서는 장애가 발생한 것으로 간주
  - 2️⃣ **블록 저장소 서버 장애**
      - 다른 서버가 **미완료 상태** 또는 **대기 상태**인 작업을 이어받아야 함
  - 3️⃣ **클라우드 저장소 장애**
      - S3 버킷(Bucket)은 다중화할 수 있음
      - 한 **지역(Region)**에서 장애 발생 시, **다른 지역**에서 파일을 가져오기
  - 4️⃣ **API 서버 장애**
      - API 서버들은 **무상태(Stateless) 서버**
      - 로드밸런서는 API 서버 장애 발생 시, 트래픽을 해당 서버로 보내지 않아 **장애 서버를 격리**
  - 5️⃣ **메타데이터 캐시 장애**
      - 메타데이터 캐시를 다중화
      - 한 노드에 장애가 생긴다면, **다른 노드**에서 데이터를 가져오기
      - 장애가 발생한 서버는 새 서버로 교체
  - 6️⃣ **메타데이터 데이터베이스 장애**
      - **주 데이터베이스 서버 장애**
          - 부 데이터베이스 서버 중 하나를 **주 데이터베이스 서버로 선정**
          - 부 데이터베이스 서버를 1개 추가
      - **부 데이터베이스 서버 장애**
          - 다른 부 데이터베이스 서버가 읽기 연산을 하도록 위임
          - 장애 서버는 새 것으로 교체
  - 7️⃣ **알림 서비스 장애**
      - 접속 중인 **모든 사용자**는 알림 서버와 **롱 폴링 연결을 하나씩 유지**
      - 알림 서비스는 많은 사용자와의 연결을 유지하는 상태, ex) Dropbox : 연결 1백만개 이상
      - 한 대 서버에 장애 발생 시, 그 서버의 모든 사용자의 **롱 폴링 연결을 다시 생성**
      - **복구는 상대적으로 느릴 수 있음 :** 많은 연결 유지 가능, 연결을 **동시에 시작하는 것은 불가능**
  - 8️⃣ **오프라인 사용자 백업 큐 장애**
      - 다중화하여 관리
      - 큐(Queue)에 장애가 발생하면, 구독 중인 클라이언트들은 **백업 큐로 구독 관계를 재설정**
  
  ---
  
</details>
<details>
  <summary><b>마무리</b></summary>
  
  ---
  
  ## 4단계: 마무리
  
  ### 추가 고려사항
  
  - 1️⃣ **파일을 클라우드 저장소에 직접 업로드**
      - 블록 저장소 서버를 거치지 않음, **업로드 시간 단축**
      - **분할, 압축, 암호화 로직을 클라이언트에 위치**
          - 플랫폼별로 따로 구현 필요, ex) iOS, Android, Web 등
          - **클라이언트의 해킹 위험** : 암호화 로직을 클라이언트에 두는 것은 적절치 않음
  - 2️⃣ **접속 상태를 관리하는 로직을 별도 서비스로 분리**
      - 다른 서비스에서도 쉽게 활용할 수 있음
  
  ---
  
</details>
