> **10장. 알림 시스템 설계**

<details>
  <summary><b>문제 이해 및 설계 범위 확정</b></summary>  
    
  ---
  
  ## 1단계: 문제 이해 및 설계 범위 확정
  
  ### 알림 시스템(Notification System)
  
  - 고객에게 중요할 만한 정보를 **비동기적으로 제공**
      - 최신 뉴스
      - 제품 업데이트
      - 이벤트
      - 선물
  - **분류**
      - 모바일 푸시 알림(Mobile Push Notification)
      - SMS 메시지
      - 이메일
          
        <img src="https://github.com/user-attachments/assets/2568e0b6-b1c0-4f77-b3bb-3413f8418b5e" width="400px"/>

          
  
  ### 요구사항 알아내기
  
  - **Q.** 어떤 종류의 알림을 지원해야 하나요?
  - **A.** 푸시 알림, SMS 메시지, 이메일
  - **Q.** 실시간(real-time) 시스템이어야 하나요?
  - **A.** 연성 실시간(soft real-time) 시스템
      - 가능한 빨리 전달되어야 하지만, 부하 상황에서 약간의 지연은 괜찮음
  - **Q.** 어떤 종류의 단말을 지원해야 하나요?
  - **A.** iOS, Android, Laptop/Desktop
  - **Q.** 사용자에게 보낼 알림은 누가 만들 수 있나요?
  - **A.** 클라언트 애플리케이션 or 서버 측 스케줄링
  - **Q.** 사용자가 알림을 받지 않도록(opt-out) 설정할 수 있어야 하나요?
  - **A.** 네, 해당 설정을 마친 사용자는 더 이상 알림을 받지 않음
  - **Q.** 하루에 몇 건의 알림을 보낼 수 있어야 하나요?
  - **A.** 천만 건의 모바일 푸시 알림, 백만 건의 SMS 메시지, 5백만 건의 이메일
  
  > **OPT OUT(옵트 아웃)**
  > 
  > 
  > 정보주체의 동의를 받지 않고 개인정보를 수집·이용한 후, 당사자가 **거부 의사**를 밝히면 개인정보 활용을 중지하는 방식
  > 
  > 당사자가 자신의 **데이터 수집을 허용하지 않는다고 명시**할 때 정보수집이 금지되는 제도
  > 
  
  ---
  
  </details>
  
<details>
  <summary><b>개략적 설계안 제시 및 동의 구하기</b></summary>
  
  ---
  
  ## 2단계: 개략적 설계안 제시 및 동의 구하기
  
  ### 알림 개략적 설계안
  
  - 알림 유형별 지원 방안
  - 연락처 정보 수집 절차
  - 알림 전송 및 수신 절차
  
  ### 1️⃣ 알림 유형별 지원 방안
  
  - ⏰ **iOS 푸시 알림**
      - iOS에서 푸시 알림을 보내기 위해 **3가지 컴포넌트**가 필요
      
    <img src="https://github.com/user-attachments/assets/19dc8225-75bd-4997-9073-b2fc3e9c385e" width="400px"/>

      - **알림 제공자(Provider)**
          - 알림 요청(Notification Request)을 만들어 애플 푸시 알림 서비스(APNS)로 보내는 주체
          - 알림 요청을 만들기 위해 필요한 데이터
              - **단말 토큰(Device Token)**
                  - 알림 요청을 보내는 데 필요한 고유 식별자
              - **페이로드(Payload)**
                  - 알림 내용을 담은 JSON 딕셔너리(Dictionary)
                  
                  ```jsx
                  // 알림 Payload 예시
                  {
                    "aps": {
                        "alert": {
                            "title": "Game Request",
                            "body": "Bob wants to play chess",
                            "action-loc-key": "PLAY"
                        },
                        "badge": 5
                    }
                  }
                  ```
                  
      - **APNS**
          - **A**pple **P**ush **N**otification **S**ervice
          - 애플이 제공하는 원격 서비스
          - 푸시 알림을 iOS 장치로 보내는 역할
      - **iOS 단말(iOS Device)**
          - 푸시 알림을 수신하는 사용자 단말
  - **⏰ 안드로이드 푸시 알림**
      - APNS 대신 **FCM(Firebase Cloud Messaging)을 사용**
      
    <img src="https://github.com/user-attachments/assets/4a2c4ff9-53f1-4a7d-90b7-cef07833b341" width="400px"/>

  - **✉️ SMS 메세지**
      - **제 3사업자(Thrid-party)의 서비스**를 많이 이용
          - 트윌리오(Twilio)
          - 넥스모(Nexmo)
      - 대부분 상용 서비스이기 때문에 이용요금을 내야 함
      
    <img src="https://github.com/user-attachments/assets/e80515cc-7f55-4d0f-8a75-38e87999fa10" width="400px"/>
      
  - **📧 이메일**
      - 대부분의 회사는 고유 이메일 서버를 구축할 역량을 갖추고 있음
      - 대부분의 많은 회사는 **상용 이메일 서비스를 이용**
          - 센드그리드(Sendgrid)
          - 메일침프(Mailchimp)
          - 전송 성공률이 높고, **데이터 분석 서비스(Analytics)**를 제공
      
    <img src="https://github.com/user-attachments/assets/7eaf7409-aa07-4a0f-8154-acc2bcd430c3" width="400px"/>
      
  
  ### 한 시스템 내의 알림 유형
  
  <img src="https://github.com/user-attachments/assets/9cd835e0-2334-4dca-a8ce-d6ba877d3194" width="400px"/>
  
  ### 연락처 정보 수집 절차
  
  - 알림을 보내기 위해 필요한 정보
      - 모바일 단말 토큰(Device Token)
      - 전화번호
      - 이메일 주소
  - **API 서버는 사용자의 정보를 수집하여 DB에 저장**
      - 앱 설치 시
      - 처음으로 계정 등록 시
      
    <img src="https://github.com/user-attachments/assets/c271c71c-5e6a-4018-b534-735556db2069" width="400px"/>

      
  - **Entity Table 설계**
      - **USER**
          - 이메일 주소
          - 전화번호
      - **DEVICE**
          - 단말 토큰
      
    <img src="https://github.com/user-attachments/assets/287cef68-3a65-4a98-a0f2-5fb3154ac660" width="400px"/>

      
      - 한 사용자는 여러 단말을 가질 수 있음(**1:N**)
      - 알림은 모든 단말에 전송되어야 함
  
  ### 알림 전송 및 수신 절차: 🎨 **개략적 설계안 (초안)**
  
  <img src="https://github.com/user-attachments/assets/501bce8f-a3df-490b-b5ee-38b9980ddcf1" width="400px"/>

  
  - **시스템 컴포넌트**
      - 1️⃣ **서비스(1~N)**
          - 마이크로서비스(Microservice)
          - 크론잡(Cronjob)
          - 분산 시스템 컴포넌트
          - ex) 납기일을 알리려는 과금 서비스(Biling Service), 배송 알림을 보내려는 쇼핑몰
      - 2️⃣ **알림 시스템(Notification System)**
          - 알림 시스템은 알림 전송/수신 처리의 핵심
          - 서비스에 알림 전송을 위한 API 제공
          - 제 3자 서비스에 전달할 알림 페이로드(Payload)를 만들어 낼 수 있어야 함
      - 3️⃣ **제 3자 서비스(Thrid Party Service)**
          - 사용자에게 실제로 알림을 전달하는 역할
          - **확장성(Extensibility)**
              - 쉽게 새 서비스를 통합, 기존 서비스 제거
          - 특정 서비스는 다른 시장에서 사용할 수 없을 수도 있음
              - ex) FCM은 중국에서 사용 불가, Jpush, PushY로 대체
      - 4️⃣ **iOS, 안드로이드, SMS, 이메일 단말**
          - 사용자는 자기 단말에서 알림을 수신
  - **문제점**
      - 1️⃣ **SPOF(Single-Point-Of-Failure)**
          - 알림 서비스에 서버가 하나만 존재
          - 알림 서비스 장애 시 전체 서비스의 장애로 이어짐
      - **2️⃣ 규모확장성**
          - 한 대 서비스로 푸시 알림에 관계된 모든 것을 처리
          - DB나 캐시 등 중요 컴포넌트의 규모를 개별적으로 늘릴 방법이 없음
      - **3️⃣ 성능 병목**
          - 알림을 처리하고 보내는 것이 자원을 많이 필요로 하는 작업일 수 있음
          - ex) HTML 페이지를 만들고 제 3자 서비스의 응답을 기다리는 일
          - 한 서버로 모든 것을 처리하면 사용자 트래픽이 몰리는 시간에 과부하 위험
  
  ### 알림 전송 및 수신 절차: 🎨 **개략적 설계안 (개선된 버전)**
  
  - **개선 방안**
      - 1️⃣ 데이터베이스와 캐시를 알림 시스템의 주 서버에서 분리
      - 2️⃣ 알림 서버를 증설하고 자동으로 Scale-out
      - 3️⃣ 메시지 큐를 이용해 시스템 컴포넌트 사이의 강한 결합을 끊음
  
  <img src="https://github.com/user-attachments/assets/1665cfd5-7459-4bb6-9fe0-cbfd03744ca7" width="400px"/>

  
  - **시스템 컴포넌트**
      - **서비스(1~N)**
          - 알림 시스템 서버의 API를 통해 알림을 보낼 서비스들
      - **알림 서버(Notification Server)**
          - **알림 전송 API**
              - 스팸 방지를 위해 보통 사내 서비스 또는 인증된 클라이언트만 이용 가능
              - ex) `POST https://api.example.com/v/sms/send`
          - **알림 검증(Validation)**
              - 이메일 주소, 전화번호 등에 대한 기본적 검증을 수행
          - **데이터베이스 또는 캐시 질의**
              - 알림에 포함시킬 데이터를 가져오는 기능
          - **알림 전송**
              - 알림 데이터를 메시지 큐에 넣음
              - 본 설계안의 경우 하나 이상의 메시지 큐 사용, 알림을 병렬적으로 처리
              
              ```jsx
              // API 호출 시 전송할 데이터(Body)
              {
                "to": [
                    {
                      "user_id": 123456
                    }
                ],
                "from": {
                    "email": "from_address@example.com"
                },
                "subject": "Hello World",
                "content": [
                    {
                      "type": "text/plain",
                      "value": "Hello World!"
                    }
                ]
              }
              ```
              
      - **캐시(Cache)**
          - 사용자 정보, 단말 정보, 알림 템플릿(Template) 등을 캐싱
      - **데이터베이스(DB)**
          - 사용자, 알림, 설정 등 다양한 정보 저장
      - **메시지 큐(Message Queue)**
          - **시스템 컴포넌트 간 의존성을 제거**하기 위해 사용
          - 다량의 알림의 전송되어야 하는 경우를 대비한 버퍼 역할
          - 본 설계안에서는 알림의 종류별로 별도 메시지 큐 사용
          - 제 3자 서비스 가운데 하나에 장애 발생 시, 다른 종류의 알림은 정상 동작
      - **작업 서버(Workers)**
          - 메시지 큐에서 전송할 알림을 꺼내서 **제 3자 서비스로 전달하는 역할을 담당**하는 서버
      - **제 3자 서비스(Third Party Service)**
      - **iOS, Android, SMS, Email 단말**
  - **동작 과정**
      - 1️⃣ API를 호출하여 알림 서버로 알림을 전달
      - 2️⃣ 알림 서버는 메타데이터(Metadata)를 캐시나 DB에서 가져옴
          - 사용자 정보
          - 단말 토큰(Device Token)
          - 알림 설정
      - 3️⃣ 알림 서버는 전송할 알림에 맞는 이벤트를 생성, 해당 큐에 삽입
          - ex) iOS 푸시 알림 이벤트 → iOS 푸시 알림 큐
      - 4️⃣ 작업 서버는 메시지 큐에서 알림 이벤트를 꺼냄
      - 5️⃣ 작업 서버는 알림을 제 3자 서비스로 전달
      - 6️⃣ 제 3자 서비스는 사용자 단말로 알림 전송
  
  ---
  
  </details>
<details>
  <summary><b>상세 설계</b></summary>
  
  ---
  
  ## 3단계: 상세 설계
  
  ### 자세히 살펴볼 내용
  
  - 안정성(Reliability)
  - 추가로 필요한 컴포넌트 및 고려사항
      - 알림 템플릿
      - 알림 설정
      - 전송률 제한(Rate Limit)
      - 재시도 매커니즘(Retry Mechanism)
      - 보안(Security)
      - 큐에 보관된 알림에 대한 모니터링과 이벤트 추적
  - 개선된 설계안
  
  ### 안정성
  
  - **데이터 손실 방지**
      - 알림 전송 시스템의 가장 중요한 요구사항 가운데 하나
      - 어떤 상황에서도 알림이 소실되어서는 안됨
      - **알림 로그(Notification Log) DB 유지**
          - 알림 데이터를 DB에 보관
          - 재시도 메커니즘을 구현
          
        <img src="https://github.com/user-attachments/assets/ee6276b0-cb7f-4614-be1a-0dc9169b2b07" width="400px"/>

          
  - **알림 중복 전송 방지**
      - 같은 알림이 여러 번 반복되는 것을 완전히 막을 수는 없음
      - 분산 시스템의 특성 상 가끔은 같은 알림이 중복되어 전송될 수 있음
      - **중복 방지 로직 도입**
          - 보내야 할 알림이 도착하면 그 이벤트 ID를 검사하여 **이전에 본 적이 있는 이벤트인지 판단**
          - 중복된 이벤트라면 버리고, 그렇지 않다면 알림 발송
      - **분산 시스템에서의 메시지 전송 방식**
          - 1️⃣ **At-most-once (최대 한 번)**
              - 메시지가 0번 또는 한 번 전송
              - 만약 메시지가 손실되면 다시 전송되지 않음
          - 2️⃣ **At-least-once (최소 한 번)**
              - 메시지가 적어도 한 번 전송되지만, 여러 번 전송될 가능성도 있음
              - 네트워크 오류나 시스템 장애로 인해 중복 전송이 발생할 수 있음
          - 3️⃣ **Exactly-once (정확히 한 번)**
              - 메시지가 정확히 한 번만 전송된다고 보장하는 방식
              - **이론적으로 불가능**
              
  
  ### 추가로 필요한 컴포넌트 및 고려사항
  
  - 1️⃣ **알림 템플릿**
      - 대형 알림 시스템은 하루에도 수백만 건 이상의 알림을 처리
      - 알림 메시지 **대부분은 비슷한 형식**
      - 템플릿을 사용하여 형식을 일관성 있게 유지, 작성 시간 감소
      - **구성 요소**
          - 인자(Parameter)
          - 스타일
          - 추적 링크(Tracking Link)
          
          ```jsx
          // 알림 템플릿 예시
          본문: 
          여러분이 꿈꿔온 상품을 우리가 준비했습니다.
          [item_name]이 다시 입고 되었습니다.
          [date]까지만 주문 가능합니다.
          
          타이틀(CTA: Call to Action):
          지금 [item_name]을 주문 또는 예약하세요.
          ```
          
  - 2️⃣ **알림 설정**
      - 사용자는 이미 너무 많은 알림을 받고 있어 쉽게 피곤함을 느낌
      - 많은 웹사이트와 앱에서는 사용자가 알림 설정을 상세히 조정할 수 있도록 함
      - **알림 설정 테이블**에 수신 관련 여부 저장
          - `bigint user_id`
          - `varchar channel` : 알림이 전송될 채널, 푸시 알림, 이메일, SMS 등
          - `boolean opt_in` : 해당 채널로 알림을 받을 것인지 여부
  - 3️⃣ **전송률 제한**
      - 사용자에게 너무 많은 알림을 보내지 않도록 하는 방법
      - 한 사용자가 받을 수 있는 알림의 빈도를 제한
      - 알림을 너무 많이 보내기 시작하면 **사용자는 알림 기능을 아예 꺼버림**
  - 4️⃣ **재시도 방법**
      - 제 3자 서비스가 알림 전송에 실패
      - 해당 알림을 재시도 전용 Queue에 넣음
      - 같은 문제가 계속 발생하면 개발자에게 통지(Alert)
  - 5️⃣ **푸시 알림과 보안**
      - iOS, Android의 경우
          - 알림 전송 API는 `appKey`와 `appSecret`를 사용하여 보안 유지
          - 인증된(Authenticated), 승인된(Verified) 클라이언트만 API를 사용하여 알림
  - 6️⃣ **큐 모니터링**
      - **Queue에 쌓인 알림의 개수**
          - 알림 시스템 모니터링에 중요한 메트릭(Matric)
          - 너무 크면 작업 서버들이 이벤트를 빠르게 처리하고 있지 못하다는 뜻
          - 작업 서버 증설 필요
          
        <img src="https://github.com/user-attachments/assets/905f3c61-11f7-43f7-91be-dcd2eac0b5b6" width="400px"/>

          
  - 7️⃣ **이벤트 추적**
      - **이벤트 추적 메트릭**
          - 알림 확인율
          - 알림 클릭율
          - 실제 앱 사용으로 이어지는 비율
      - **데이터 분석 서비스(Analytics)는 보통 이벤트 추적 기능을 제공**
          - 알림 시스템 구현 시 데이터 분석 서비스와 통합 필요
      - **데이터 분석 서비스를 통해 추적하는 알림 시스템 이벤트**
          
        <img src="https://github.com/user-attachments/assets/1ec4d80b-cdd5-46a7-b1a4-3eb40490a25a" width="400px"/>


          
  
  ### 수정된 설계안
  
  <img src="https://github.com/user-attachments/assets/180f22e4-2648-42d5-9c7b-f1a83bbdf340" width="400px"/>

  - 새로운 컴포넌트들이 추가됨
      - 1️⃣ 알림 서버에 인증(Authentication)과 전송률 제한(Rate-limiting) 기능 추가
      - 2️⃣ 전송 실패에 대응하기 위한 재시도 기능 추가
          - 전송에 실패한 알림은 Queue에 넣고 지정된 횟수만큼 재시도
      - 3️⃣ 전송 템플릿을 사용하여 알림 생성 과정을 단순화하고 알림 내용의 일관성 유지
      - 4️⃣ 모니터링과 추적 시스템을 추가하여 시스템 상태를 확인하고 추후 시스템 개선 대비
  
  ---

</details>
<details>
  <summary><b>마무리</b></summary>
  
  ---
  
  ## 마무리
  
  ### **알림 기능 예시**
  
  - 넷플릭스 신작 영화 출시 정보
  - 신규 상품에 대한 할인 쿠폰 이메일
  - 온라인 쇼핑 결제 확정 메시지
  
  ### 알림 시스템
  
  - **안정성(Reliability)**
      - 메시지 전송 실패율을 낮추기 위해 안정적인 재시도 메커니즘 도입
  - **보안(Security)**
      - 인증된 클라이언트만이 알림을 보낼 수 있도록 `appKey`, `appSecret` 등 이용
  - **이벤트 추적 및 모니터링**
      - 알림이 만들어진 후, 성공적으로 전송되기까지의 과정 추적
      - 알림 전송의 각 단계마다 이벤트를 추적하고 모니터링할 수 있는 시스템 통합
  - **사용자 설정**
      - 사용자가 알림 수신 설정을 조정할 수 있도록 함
      - 알림을 보기 전 반드시 해당 설정을 확인하도록 시스템 설계
  - **전송률 제한**
      - 사용자에게 알림을 보내는 빈도(Frequency)를 제한할 수 있도록 함
  
  ---

</details>
