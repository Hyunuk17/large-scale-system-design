> **14장. 유튜브 설계**

<details>
  <summary><b>문제 이해 및 설계 범위 확정</b></summary>  
    
  ---
  
  ## 1단계: 문제 이해 및 설계 범위 확정
  
  ### 유튜브 시스템(Youtube System)
  
  - **비디오 플랫폼 설계**
      - 넷플릭스(Netflix)
      - 훌루(Hulu)
  - **유튜브 이용 통계**
      - 월간 능동 사용자 수 : 20억 (2billion)
      - 매일 재생되는 비디오 수 : 50억 (5billion)
      - 미국 성인 가운데 73%가 유튜브 이용
      - 5천만(50million)명의 창작자
      - 유튜브의 광고 수입 : 2019년 기준 15억(15.1billion) 달러, 2018년도 대비 36% 증가
      - 모바일 인터넷 트래픽 중 37%를 점유
      - 80개 언어로 이용 가능
  
  ### **유튜브의 기능**
  
  - 비디오 시청
  - 댓글(Comment)
  - 비디오 공유
  - 좋아요
  - 재생목록(Playlist)에 저장
  - 채널을 구독(Subscribe)
  
  ### 요구사항 파악
  
  - **Q.** 어떤 기능이 가장 중요한지?
  - **A.** 비디오를 업로드하고, 시청하는 기능
  - **Q.** 어떤 클라이언트를 지원해야 하는지?
  - **A.** 모바일 앱, 웹 브라우저, 스마트 TV
  - **Q.** 일간 능동 사용자 수는?
  - **A.** 5백만(5million)명
  - **Q.** 사용자가 평균적으로 소비하는 시간은?
  - **A.** 30분
  - Q. 다국어 지원이 필요한지?
  - **A.** 모든 언어로 이용 가능해야 함
  - **Q.** 어떤 비디오 해상도를 지원해야 하는지?
  - **A.** 현존하는 비디오 종류와 해당도를 배부분 지원해야 함
  - **Q.** 암호화가 필요한지?
  - **A.** 필요
  - **Q.** 비디오 파일 크기에 제한이 있는지?
  - **A.** 작은 비디오 또는 중간 비디오에 초점을 맞춤, 최대 1GB 크기 제한
  - **Q.** Amazon, Google, Microsoft의 클라우드 서비스를 활용할 수 있는지?
  - **A.** 활용하는 것이 바람직함, 회사가 모든 부분을 구축하는 것은 무리에 가까움
  
  ### 비디오 스트리밍 서비스 기능
  
  - 빠른 비디오 업로드
  - 원활한 비디오 재생
  - 재생 품질 선택 기능
  - 낮은 인프라 비용(Infrastructure Cose)
  - 높은 가용성과 규모 확장성, 안정성
  - 지원 클라이언트 : 모바일 앱, 웹 브라우저, 스마트 TV
  
  ### 개략적 규모 추정
  
  - 일간 능동 사용자(DAU, Daily Active User) 수는 5백만(5million)
  - 한 사용자는 하루에 평균 **5개의 비디오**를 시청
  - 10%의 사용자가 **하루에 1비디오 업로드**
  - 비디오 **평균 크기는 300MB**
  - 비디오 저장을 위해 매일 새로 요구되는 저장 용량 :  $5백만 * 10\% * 300MB = 150TB$
  - **CDN 비용**
      - 클라우드 CDN을 통해 비디오를 서비스할 경우, CDN에서 나가는 데이터의 양에 따라 과금
      - Amazone의 **클라우드프론드(CloudFront)** CDN : 1GB당 $0.02의 요금 발생(미국)
      - 문제를 단순화하기 위해 비디오 스트리밍 비용만 책정
      - 매일 발생하는 요금 : $5백만 * 5비디오 * 0.3GB * \$0.02 = \$150,000$
      - CDN을 통해 비디오 서비스 시 비용이 너무 높음 : **비용을 줄이는 설계 필요**
  
  ---
  
  </details>
  
<details>
  <summary><b>개략적 설계안 제시 및 동의 구하기</b></summary>
  
  ---
  
  ## 2단계: 개략적 설계안 제시 및 동의 구하기
  
  ### 기존의 클라우드 서비스 활용
  
  - CDN, BLOB 스토리지(BLOB Storage)의 경우, 기존 클라우드 서비스 활용
  - 규모 확장이 쉬운 BLOB 저장소나 CDN을 만드는 것은 복잡하고 비용이 많이 필요
  - 회사가 모든 것을 스스로 구축하지는 않음
      - ex) Netflix : Amazon Cloud Service 이용, Facebook : 아카마이(Akamai) CDN 이용
  
  ### 시스템 컴포넌트
  
  <img src="https://github.com/user-attachments/assets/a81dc3fe-2999-4453-8301-5f8d42a7d5df" width="400px"/>

  - **단말(Client)**
      - 컴퓨터, 모바일 폰, 스마트 TV를 통해 Youtube를 시청할 수 있음
  - **CDN**
      - 비디오는 CDN에 저장
      - 재생 버튼을 누르면 CDN으로부터 스트리밍이 이루어짐
  - **API 서버**
      - 비디오 스트리밍을 제외한 모든 요청을 처리
          - 피드 추천(Feed Recommendation)
          - 비디오 업로드 URL 생성
          - 메타데이터 데이터베이스, 캐시 갱신
          - 사용자 가입
          
  
  ### 1. 비디오 업로드 절차
  
  <img src="https://github.com/user-attachments/assets/34df4836-0b3d-43dd-9546-99e32d04d0ad" width="400px"/>


  - **1️⃣ 사용자**
      - 컴퓨터, 모바일 폰, 스마트 TV를 통해 Youtube를 시청하는 이용자
  - **2️⃣ 로드밸런서(Load Balancer)**
      - API 서버 각각으로 고르고 요청을 분산
  - **3️⃣ API 서버**
      - 비디오 스트리밍을 제외한 다른 모든 요청을 처리
  - **4️⃣ 메타데이터 데이터베이스(Metadata DB)**
      - 비디오의 메타데이터를 보관
      - **샤딩(Sharding)**과 **다중화(Replication)**를 적용하여 성능 및 가용성 요구사항 충족
  - **5️⃣ 메타데이터 캐시(Metadata Cache)**
      - 성능을 높이기 위해 비디오 메타데이터와 사용가 객체(User Object)는 캐싱
  - **6️⃣ 원본 저장소(Original Storage)**
      - 원본 비디오를 보관할 **대형 이진 파일 저장소**(**BLOB**, Binary Large Object Storage) 시스템
      - 이진 데이터를 하나의 개체로 보관하는 데이터베이스 관리 시스템
  - **7️⃣ 트랜스코딩 서버(Transcoding Server)**
      - 비디오 트랜스코딩(비디오 인코딩) : **비디오의 포맷(MPEG, HLS 등)을 변환**하는 절차
      - 단말이나 대역폭 요구사항에 맞는 최적의 비디오 스트림을 제공하기 위해 사용
  - **8️⃣ 트랜스코딩 비디오 저장소(Transcoded Storage)**
      - 트랜스코딩이 완료된 비디오를 저장하는 BLOB 저장소
  - **9️⃣ CDN**
      - 비디오를 캐싱하는 역할
      - 사용자가 재생 버튼을 누르면 CDN을 통해 비디오 스트리밍이 이루어짐
  - **1️⃣0️⃣ : 트랜스코딩 완료 큐(Completion Queue)**
      - 비디오 트랜스코딩 완료 이벤트들을 보관할 메시지 큐
  - **1️⃣1️⃣ : 트랜스코딩 완료  핸들러(Completion Handler)**
      - 트랜스코딩 완료 큐에서 이벤트 데이터를 꺼내 처리할 작업 서버들
      - 메타데이터 캐시와 데이터베에스를 갱신
  
  ### 2-1. 비디오 업로드 프로세스
  
  <img src="https://github.com/user-attachments/assets/df74694a-0b78-4206-b55e-ec17c73158fe" width="400px"/>

  - **비디오를 웝본 저장소에 업로드**
  - **트랜스코딩 서버는 원본 저장소에서 해당 비디오를 가져와 트랜스코딩 시작**
  - **트랜스코딩 완료 후, 다음 2개의 절차를 병렬적으로 수행**
      1. 완료된 비디오를 트랜스코딩 비디오 저장소로 **업로드**
          - 트랜스코딩이 끝난 비디오를 CDN에 올림
      2. 트랜스코딩 완료 이벤트를 트랜스코딩 **완료 큐에 넣음**
          - 완료 핸들러가 이벤트 데이터를 큐에서 꺼냄
          - 완료 핸들러가 메타데이터 데이터베이스와 캐시를 갱신
  - **API 서버가 단말에게 비디오 업로드가 끝나, 스트리밍 준비가 되었음을 알림**
  
  ### 2-2 비디오 메타데이터 갱신 프로세스
  
  <img src="https://github.com/user-attachments/assets/445f1342-5114-4a8f-a8b3-178786b0f7f1" width="400px"/>

  - **단말은 비디오 메타데이터 갱신 요청을 API 서버에 전송**
      - 원본 저장소에 파일이 업로드되는 동안 병렬적으로 진행됨
  - **API 서버는 메타데이터 캐시와 데이터베이스를 업데이트**
  
  > **비디오 메타데이터**
  > 
  > 
  > 비디오 URL, 비디오 크기, 해상도, 포맷, 사용자 정보 
  > 
  
  ### 2. 비디오 스트리밍 절차
  
  - **비디오 재생버튼을 누르면 스트리밍이 바로  시작**
      - **스트리밍** : 단말이 원격지의 비디오로부터 지속적으로 **비디오 스트림**을 전송받아 재생
      - 비디오 다운로드의 완료를 기다릴 필요 없음
  - **스트리밍 프로토콜(Streaming Protocol)**
      - 비디오 스트리밍을 위해 데이터를 전송할 때 쓰이는 표준화된 통신방법
      - 프로토콜마다 지원하는 비디오 인코딩과 플레이어가 다름
      - 서비스의 용도에 맞는 프로토콜을 잘 선택해야 함
  - **스트리밍 프로토콜 종류**
      - **MPEG-DASH**, **M**oving **P**icture **E**xperts **G**roup-**D**ynamic **A**daptive **S**treaming over **H**TTP
      - **애플(Apple) HLS**(**H**TTP **L**ive **S**treaming)
      - **마이크로소프트 스무드 스트리밍**(Mircosoft Smooth Streaming)
      - **어도비 HTTP 동적 스트리밍**(Adobe **H**TTP **D**ynamic **S**treaming, HDS)
  - **CDN**
      
    <img src="https://github.com/user-attachments/assets/564df6f7-0645-4398-9bcd-940c605a8fcd" width="200px"/>

      - 사용자 단말에 가장 가까운 **CDN 엣지 서버(Edge Server)**가 비디오 전송을 담당
      - 전송 지연이 아주 낮음
  
  ---
  
  </details>
<details>
  <summary><b>상세 설계</b></summary>
  
  ---
  
  ## 3단계: 상세 설계
  
  ### 비디오 트랜스코딩
  
  - **비디오 파일을 다른 형식으로 변환하는 프로세스**
      - **매개 변수 조정** : ex) ****해상도, 인코딩 방식, 비트 전송률
      - 단말은 비디오를 녹화하여 특정 포맷으로 저장
          - 다른 단말에서도 재생할 수 있도록 호환되는 **비트레이트**와 **포맷**으로 저장되어야 함
  - **비디오 트랜스코딩 필요성**
      - **가공되지 않은 원본 비디오(Raw Video)는 저장 공간을 많이 차지**
          - ex) 초당 60프레임으로 녹화된 HD 비디오는 수백 GB의 저장공간 차지
      - **상당수의 단말과 브라우저는 특정 종류의 비디오 포맷만 지원**
          - 호환성 문제를 해결하기 위해 하나의 비디오를 여러 포맷으로 인코딩
      - **사용자에게 끊김 없는 고화질 비디오 재생을 보장**
          - 네트워크 대역폭이 충분하지 않은 사용자에게 저화질 비디오 전송
          - 네트워크 대역폭이 충분한 사용자에게 고화질 비디오 전송
      - **모바일 단말의 경우 네트워크 상황이 수시로 변경될 수 있음**
          - 비디오가 끊김 없이 재생되도록 하기 위해 비디오 화질 자동/수동 변경
  - **인코딩 포맷**
      - **1️⃣ 컨테이너(Container)**
          - 비디오 파일, 오디오, 메타데이터를 담는 일종의 바구니
          - ex) `.avi`, `.mov`, `.mp4`
      - **2️⃣ 코덱(Codec)**
          - 비디오 화질은 보존하면서 파일 크기를 줄일 목적으로 고안된 압축/압축해제 알고리즘
          - ex) `H.264`, `VP9`, `HEVC`
      
  
  > **비트레이트(Bitrate)**
  > 
  > 
  > 비디오를 구성하는 **비트가 얼마나 빨리 처리되어야 하는지**를 나타내는 단위 
  > 
  > **특정 시간 단위 동안 처리되는 비트의 수** 
  > 
  > 비트레이트가 높은 비디오 
  > 
  > - 일반적으로 고화질 비디오
  > - 비디오 스트림을 정상 재생하기 위해 보다 좋은 **컴퓨팅 파워 성능**과 **인터넷 회선 속도** 필요
  
  ### 유항 비순환 그래프(DAG) 모델
  
  - **비디오 프로세스 요구사항**
      - 비디오 위에 워터마크(Watermark) 표시
      - 섬네일(Thumbnail) 이미지를 직접 지정
      - 고화질 비디오
      - 저화질 비디오
  - **추상화 도입**
      - 비디오 프로세싱 파이프라인 지원, 처리 과정의 **병렬렁을 높임**
      - 클라이언트 프로그래머가 **실행할 작업(Task)을 손수 정의**할 수 있도록 지원
      - ex) Facebook 스트리밍 비디오 엔진 : 유향 비순환 그래프(DAG)를 통해 병렬 처리
  - **DAG 모델**
      - Directed Acycle Graph, 유향 비순환 그래프
      - 작업을 단계별로 배열할 수 있도록 하여 해당 작업들의 **순차적/병렬적 처리 지원**
      
    <img src="https://github.com/user-attachments/assets/9635a77a-4168-4738-962b-e77ae708c873" width="400px"/>

      - 원본 비디오 : **일반 비디오**, **오디오**, **메타데이터** 3부분으로 나누어 처리
      - **비디오**
          - **검사(Inspection)**
              - 비디오 품질 검사
              - 비디오 손상 확인
          - **비디오 인코딩(Video Encoding)**
              
            <img src="https://github.com/user-attachments/assets/87c6f3c1-333a-40f3-b003-fc1d1f64f251" width="400px"/>

              - 비디오를 다양한 해상도, 코덱, 비트레이드의 조합으로 인코딩
              - 비디오 인코딩의 결과로 새로운 비디오 파일을 생성
          - **섬네일(Thumbnail)**
              - 사용자가 업로드한 이미지로 섬네일 생성
              - 비디오에서 자동 추출된 이미지로 섬네일 생성
          - **워터마크(Watermark)**
              - 비디오에 대한 식별정보를 이미지 위에 오버레이(Overlay) 형태로 표시
  
  ### 비디오 트랜스코딩 아키텍처
  
  <img src="https://github.com/user-attachments/assets/6d7fb9c8-d9bd-4d24-8bbe-a70c2511f060" width="400px"/>

  - **주요 컴포넌트**
      - 전처리기(Preprocessor)
      - DAG 스케줄러
      - 자원 관리자(Resource Manager)
      - 작업 실행 서버(Resource Worker)
      - 임시 저장소(Temporary Storage)
  - 1️⃣ **전처리기**
      - **비디오 분할(Video Splitting)**
          - 비디오 스트림을 **GOP 단위로 쪼갬**
          - GOP(Group Of Pictures) ****: 특정 순서로 배열된 **프레임(Frame) 그룹**
          - 하나의 GOP는 **독립적으로 재생 가능**, 보통 몇 초 정도 길이
          - 오래된 단말이나 브라우저는 GOP 단위 분할을 지원하지 않음 : 전처리기가 대신 수행
      - **DAG 생성**
          - 클라이언트 프로그래머가 작성한 설정 파일에 따라 DAG를 생성
          - ex) **`다운로드`-`트랜스 코딩` DAG**
              
              ```jsx
              // Task: download-input
              task {
                  name 'downlaod-input'
                  type 'Downlaod'
                  input {
                      url config.url
                  }
                  output { it ->
                      context.inputVideo = it.file
                  }
                  next 'transcode' // 다음 실행할 Task
              }
              ```
              
              ```jsx
              // Task: transcode
              task {
                  name 'transcode'
                  type 'Transcode'
                  input {
                      input context.inputVideo
                      config config.transConfig
                  }
                  output { it ->
                      context.file = it.outputVideo
                  }
              }
              ```
              
      - **데이터 캐시**
          - 전처리기는 **분할된 비디오를 캐싱**
          - 안정성을 높이기 위해 전처리기는 **GOP와 메타데이터를 임시 저장소에 보관**
          - 비디오 인코딩이 실패하면 시스템은 보관된 데이터를 활용해 인코딩 재개
  - 2️⃣ **DAG 스케줄러**
      - DAG 그래프를 몇 개의 **단계(Starge)로 분할**
      - 각 단계를 자원 관리자의 작업 큐(Task Queue) 넣음
      
    <img src="https://github.com/user-attachments/assets/5b8c331d-1957-462d-a940-3c0bbc277d41" width="400px"/>

      - 예시) DAG 스케줄러
          - 1단계 : `비디오`, `오디오`, `메타데이터` 분리
          - 2단계 : `[비디오 파일 인코딩, 섬네일 추출]`, `[오디오 인코딩]`
  - 3️⃣ **자원 관리자**
      
    <img src="https://github.com/user-attachments/assets/64f143f8-ff58-4215-a333-59c8f26c1128" width="400px"/>

      - **3개의 Queue와 작업 스케줄러로 구성**
          - **작업 큐(Task Queue) :** 실행할 작업이 보관되어 있는 우선순위 큐(Priority Queue)
          - **작업 서버 큐(Worker Queue) :** 작업 서버의 가용 상태 정보가 보관되어 있는 우선순위 큐
          - **실행 큐(Running Queue) :** 실행 중인 작업 및 작업 서버 정보가 보관되어 있는 큐(Queue)
          - **작업 스케줄러(Task Scheduler)**
              - 최적의 작업/서버 조합을 선택
              - 해당 작업 서버가 작업을 수행하도록 지시
      - **작업 관리자 동작**
          1. 작업 큐에서 가장 높은 우선순위의 작업을 꺼냄(Poll)
          2. 작업 관리자는 해당 작업을 실행하기 적합한 작업 서버를 선택
          3. 작업 스케줄러는 해당 작업 서버에서 작업 실행을 지시
          4. 작업 스케줄러는 작업이 어떤 서버에게 할당되었는지에 대한 정보를 실행 큐에 삽입(Offer)
          5. 작업 스케줄러는 작업이 완료되면 해당 작업을 실행 큐에서 제거
  - 4️⃣ **작업 실행 서버**
      
    <img src="https://github.com/user-attachments/assets/86d8d093-53f6-483c-a538-2a4596ba3d99" width="400px"/>

      - DAG에 정의된 작업을 수행
      - 작업 종류에 따라 작업 서버도 구분하여 관리 : ex) 워터마크, 인코딩, 섬네일, 병합 등
  - 5️⃣ **임시 저장소**
      - 여러 저장소 시스템을 활용할 수 있음 : ex) Redis, S3, Disk 등
      - 저장할 데이터의 유형, 크기, 이용 빈도, 데이터 유효기간을 고려
          - ex) 메타데이터 : 작업 서버가 빈번히 참조, 크기가 작읍 : 메모리에 캐시
          - ex) 비디오/오디오 데이터 : BLOB 저장소
      - 임시 저장소에 보관한 데이터는 비디오 프로세싱이 완료되면 삭제
  - **6️⃣ 인코딩된 비디오**
      - 인코딩 파이프라인의 최종 결과물
      - ex) `funny_720p.mp4`
  
  ### 시스템 최적화
  
  ### 속도 최적화
  
  - 1️⃣ **비디오 병렬 업로드**
      
    <img src="https://github.com/user-attachments/assets/12e6b2ae-8ee2-4012-bbb2-27c2282fb7d0" width="400px"/>

      - 비디오 전부를 한 번의 업로드로 올리는 것은 비효율적
      - 하나의 비디오를 작은 **GOP들로 분할, 병렬 업로드** : 일부가 실패해도 빠르게 업로드 재개
      
    <img src="https://github.com/user-attachments/assets/19dff43e-5c27-4940-be95-24aaadfe9090" width="400px"/>

      - 단말이 비디오를 GOP 경계에 맞춰 분할 : 업로드 속도 증가
  - 2️⃣ **업로드 센터를 사용자 근거리에 지정**
      
    <img src="https://github.com/user-attachments/assets/e212c3f9-1dc5-4e2e-9db7-4fd1304bd23e" width="400px"/>

      - 업로드 센터를 여러 곳에 구축 : ex) 미국 거주자 - 북미 지역 업로드 센터
      - CDN을 업로드 센터로 이용
  - 3️⃣ **모든 절차를 병렬화**
      - 느슨하게 결합된 시스템을 만들어 시스템의 병렬성을 증가
      
    <img src="https://github.com/user-attachments/assets/ee986a9f-5d57-428a-aec2-212953e6da6d" width="400px"/>

      - 의존성 : **이전 단계의 결과물을 입력**으로 사용, 병렬성을 높이기 어려움
      - **기존 시스템**
          - 인코딩 모듈은 다운로드 모듈의 작업이 끝나는 것을 기다림
      
    <img src="https://github.com/user-attachments/assets/5773f1b8-62ea-4d1f-8974-60713323cd96" width="400px"/>

      - **메시지 큐(Message Queue) 도입**
          - 인코딩 모듈은 다운로드 모듈의 작업 완료를 기다리지 않음
          - 메시지 큐에 보관된 **이벤트 각각**을 인코딩 모듈이 **병렬적으로 처리**
  
  ### 안전성 최적**화**
  
  - 1️⃣ **미리 사인된 업로드 URL**
      - **허가받은 사용자(Authorized User)**만이 올바른 장소에 비디오를 업로드
      
    <img src="https://github.com/user-attachments/assets/311c2128-4887-4500-89ab-bfa6a3ef825a" width="400px"/>

      - **클라이언트는 HTTP 서버에 POST 요청 미리 사인된 업로드 URL**을 받음
          - 해당 URL이 가리키는 객체(Object)에 대한 접근 권한이 이미 주어져 있는 상태
          - 제한된 시간동안 데이터 업로드를 허용
          - ex)
              - 미리 사인된(Pre-signed) 업로드 URL : S3에서 사용되는 용어
              - 접근 공유 시그니처(Shared Access Signature) : 마이크로소프트 Azure BLOB 저장소
      - **API 서버는 미리 사인된 URL을 반환**
      - **클라이언트는 해당 URL이 가리키는 위치에 비디오를 업로드**
  - 2️⃣ **비디오 보호**
      - **콘텐츠 제작자의 업로드 우려 :** 비디오 원본 도난
      - **디지털 저작권 관리(DRM : Digital Rights Management) 시스템 도입**
          - 애플의 페어플레이(FiarPlay)
          - 구글의 와이드바인(Widevine)
          - 마이크로소프트의 플레이레디(PlayReady)
      - **AES 암호화(Encryption)**
          - 비디오를 암호화하고, 접근 권한을 설정
          - 암호화된 비디오는 재생 시에만 복호화
          - 허락된 사용자만 암호화된 비디오를 시청할 수 있음
      - **워터마크(Watermark)**
          - 비디오 위에 소유자 정보를 포함하는 이미지 오버레이를 올림
          - ex) 회사 로고, 이름
  
  ### 비용 최적화
  
  - **CDN**
      - 세계 어디에서도 끊김 없이 빠르게 비디오를 시청할 수 있도록 지원
      - 데이터 크기가 클수록 비용이 비쌈
  - **롱테일(Long-tail) 분포**
      - 인기있는 비디오는 빈번히 재생
      - 나머지는 거의 보는 사람이 없음
  - **최적화 방안**
      
    <img src="https://github.com/user-attachments/assets/271c59ea-d274-4698-98a0-e84428dd0861" width="400px"/>

      - 1️⃣ **인기 있는 비디오는 CDN을 통해 재생**, **나머지 비디오는 비디오 서버**를 통해 재생
      - **2️⃣ 인기가 별로 없는 비디오는 인코딩할 필요가 없을 수 있음**
          - 짧은 비디오라면, 필요할 때 인코딩하여 재생
      - 3️⃣ **특정 지역에서만 인기가 높은** 비디오 : 다른 지역에 옮길 필요 없음
      - **4️⃣ CDN을 직접 구축하고 인터넷 서비스 제공자(ISP, Internet Service Provider)와 제휴**
          - CDN 직접 구축
              - 초대형 프로젝트, 대규모 스트리밍 사업자만 고려 추천
          - ISP
              - 컴캐스트(Comcast)
              - AT&T
              - 버라이즌(Verizon)
  
  ### 오류 처리
  
  - 시스템 오류는 대형 시스템에서 불가피
  - **장애를 아주 잘 감내하는(Highly Fault-tolerant) 시스템**
      - 오류를 우아하게 처리
      - 빠르게 회복
  - **시스템 오류**
      - 1️⃣ **회복 가능 오류(Recoverable Error)**
          - **재시도(Retry)**하여 해결
          - 계속해서 실패하고 복구가 어렵다 판단되면, 클라이언트에게 **적절한 오류 코드를 반환**
          - ex) 특정 비디오 세그먼트를 트랜스코딩하다 실패
      - 2️⃣ **회복 불가능 오류(Non-recoverable Error)**
          - 해당 비디오에 대한 **작업을 중단**하고, 클라이언트에게 **적절한 오류 코드 반환**
          - ex) 비디오 포맷이 잘못됨
  - **전형적 오류 해결방법**
      - **업로드 오류 :** 몇 회 재시도
      - **비디오 분할 오류**
          - 낡은 버전의 클라이언트가 GOP 경계에 따라 분할하지 못함
          - 전체 비디오를 서버로 전송, 서버가 해당 비디오 분할을 처리
      - **트랜스코딩 오류 :** 재시도
      - **전처리 오류** : DAG 그래프를 재생성
      - **DAG 스케줄러 오류** : 작업을 다시 스케줄링
      - **자원 관리자 큐에 장애 발생** : 사본(Replica)을 이용
      - **작업 서버 장애** : 다른 서버에서 해당 작업을 재시도
      - **API 서버 장애** : API 서버는 무상태(Stateless) 서버이므로, 신규 요청은 다른  API 서버로 우회
      - **메타데이터 캐시 서버 장애**
          - 데이터는 다중화되어 있음, 다른 노드에서 데이터를 가져옴
          - 캐시 서버는 교체
      - **메타데이터 데이터베이스 서버 장애**
          - 주 서버가 죽었다면, 부 서버 가운데 하나를 주 서버로 교체
          - 부 서버가 죽었다면, 다른 부 서버를 통해 읽기 연산을 처리, 죽은 서버 교체
  
  ---

</details>
<details>
  <summary><b>마무리</b></summary>
  
  ---
  
  ## 4단계: 마무리
  
  ### 추가적인 고려사항
  
  - **API 계층의 규모 확장성 확보 방안**
      - API 서버는 무상태(Stateless) 서버
      - 수평적 규모 확장이 가능함
  - **데이터베이스 계층의 규모 확장성 확보 방안**
      - 다중화
      - 샤딩
  - **라이브 스트리밍(Live Streaming)**
      - 비디오를 실시간으로 녹화하고 방송하는 절차
      - 라이브 스트리밍의 경우, **응답지연이 더 낮아야 함 :** 스트리밍 프로토콜 선정에 유의
      - **병렬화 필요성이 떨어짐** : 작은 단위 데이터의 빠른 실시간 처리가 더 중요
      - **오류 처리 방안** : 너무 많은 시간이 걸리는 방안을 사용하기 어려움
  - **비디오 삭제(Takedown)**
      - 업로드 과정에서 식별
      - 사용자의 신고 절차를 통해 판별
      - ex) 저작권을 위반한 비디오, 선정적 비디오, 불법적 행위에 관한 비디오
  
  ---
  
</details>
