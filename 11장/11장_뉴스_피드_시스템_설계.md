> **11장. 뉴스 피드 시스템 설계**

<details>
  <summary><b>문제 이해 및 설계 범위 확정</b></summary>  
  
  ---
  
  ## 1단계: 문제 이해 및 설계 범위 확정
  
  ### 뉴스 피드(News Feed)
  
  - 홈페이지 중앙에 지속적으로 업데이트되는 스토리들
      - 사용자 상태 정보 업데이트
      - 사진
      - 비디오
      - 링크
      - 앱 활동(App Activity)
      - 팔로우하는 사람들, 페이지, 그룹으로부터 나오는 좋아요(Likes)
  - 여러 유형
      - 페이스북 뉴스 피드
      - 인스타그램 피드
      - 트위터 타임라인
      
  
  ### 요구사항 알아내기
  
  - **Q.** 모바일 앱을 위한 시스템인가요? 아니면 웹? 둘다 지원?
  - **A.** 둘 다 지원
  - **Q.** 중요한 기능으로는 어떤 것이 있나요?
  - **A.** 사용자는 뉴스 피드 페이지에 새 스토리를 올리고, 친구들의 스토리를 볼 수 있어야 함
  - **Q.** 뉴스 피드에는 어떤 순서로 스포리가 표시되어야 하나요?
      - 최신 포스트가 위로
      - 토픽 점수(Topic Score) 같은 다른 기준, ex) 가까운 친구
  - **A.** 단순히 시간 흐름 역순(Reverse Chronological Order) 표시
  - **Q.** 한 명의 사용자는 최대 몇 명의 친구를 가질 수 있나요?
  - **A.** 최대 5,000명
  - **Q.** 트래픽 규모는 어느 정도인가요?
  - **A.** 매일 천만 명이 방문한다고 가정(10milion DAU)
  - **Q.** 피드에 이미지나 비디오 스토리도 올라올 수 있나요?
  - **A.** 스토리에는 이미지나 비디오 등의 미디어 파일이 포함될 수 있음
  
  ---
  
  </details>
  
<details>
  <summary><b>개략적 설계안 제시 및 동의 구하기</b></summary>
  
  ---
  
  ## 2단계: 개략적 설계안 제시 및 동의 구하기
  
  ### 개략적 설계안
  
  - **1️⃣ 피드 발행(Feed Publishing)**
      - 사용자가 스토리를 포스팅(Posting)하면 해당 데이터를 Cache와 DB에 기록
      - 새 포스팅은 친구의 뉴스 피드에도 전송
  - **2️⃣ 뉴스 피드 생성(News Feed Building)**
      - 뉴스 피드는 모든 친구의 포스팅을 시간 흐름 역순으로 모아서 만든다고 가정
      
  
  ### 뉴스 피드 API
  
  - 클라이언트가 서버와 통신하기 위해 사용하는 수단
      - 상태 정보 업데이트
      - 뉴스 피드 불러오기
      - 친구 추가
  - HTTP 프로토콜 기반
  - 1️⃣ **피드 발행 API**
      - 새 스토리를 포스팅하기 위한 API
      - **HTTP POST**, ex) `POST /v1/me/feed`
      - **파라미터**
          - Authorization 헤더 : API 호출을 인증하기 위해 사용
          - 바디(Body) : 포스팅 내용
  - 2️⃣ **피드 읽기 API**
      - 뉴스 피드를 가져오는 API
      - **HTTP GET**, ex) `GET /v1/me/feed`
      - **파라미터**
          - Authorization 헤더 : API 호출을 인증하기 위해 사용
  
  ### 피드 발행
  
  <img src="https://github.com/user-attachments/assets/5e958405-c279-4def-8f58-8e06e5d03f02" width="400px"/>
  
  - **사용자**
      - 모바일 앱이나 브라우저에서 새 포스팅을 올리는 주체
      - `POST /v1/me/feed` API 사용
  - **로드밸런서(Load Balancer)**
      - 트래픽을 웹 서버들로 분산
  - **웹 서버(Web Server)**
      - HTTP 요청을 내부 서비스로 중계하는 역할
  - **포스팅 저장 서비스(Post Service)**
      - 새 포스팅을 DB와 Cache에 저장
  - **포스팅 전송 서비스(Fanout Service)**
      - 새 포스팅을 친구의 뉴스 피드에 푸시(Push)
      - 뉴스 피드 데이터는 Cache에 보관하여 빠르게 읽어갈 수 있도록 함
  - **알림 서비스(Notification Service)**
      - 친구들에게 새 포스팅이 올라왔음을 알리거나 푸시 알림을 보내는 역할
  
  ### 뉴스 피드 생성
  
  <img src="https://github.com/user-attachments/assets/82b48688-4475-467b-b68e-d3f52a2c46ef" width="400px"/>

  - **사용자**
      - 뉴스 피드를 읽는 주체
      - `GET /v1/me/feed` API 사용
  - **로드 밸런서**
      - 트랙픽을 웹 서버들로 분산
  - **웹 서버**
      - 트래픽을 뉴스 피드 서비스로 보냄
  - **뉴스 피드 서비스(News Feed Service)**
      - Cache에서 뉴스 피드를 가져오는 서비스
  - **뉴스 피드 캐시(News Feed Cache)**
      - 뉴스 피드를 렌더링할 때 필요한 피드 ID를 보관
  
  ---
  
  </details>
<details>
  <summary><b>상세 설계</b></summary>
  
  ---
  
  ## 3단계: 상세 설계
  
  ### 피드 흐름 **상세 설계**
  
  - **웹 서버**
      - **클라이언트와 통신**
      - **인증**
          - 올바른 인증 토큰을 Authorization 헤더에 탑재했는지 확인
      - **처리율 제한**
          - 한 사용자가 올릴 수 있는 포스팅의 수에 제한
          - 스팸을 막고 유해한 콘텐츠가 자주 올라오는 것을 방지
  - **포스팅 전송(팬아웃, Fanout) 서비스**
      - **팬아웃**
          - 포스팅 전송
          - 새 포스팅을 그 사용자와 친구 관계에 있는 모든 사용자에게 전달하는 과정
      - 1️⃣ **쓰기 시점에 팬아웃하는 모델(Fanout-on-Write) // TODO: 203p**
          - **푸시(Push) 모델**
          - **동작 원리**
              - 새로운 포스트를 기록하는 시점에 뉴스 피드를 갱신
              - 포스팅이 완료되면 바로 해당 사용자의 캐시에 해당 포스팅을 기록
          - **장점**
              - 뉴스 피드가 실시간으로 갱신
              - 친구 목록에 있는 사용자에게 즉시 전송
              - 새 포스팅이 기록되는 순간에 뉴스 피드가 이미 갱신(Pre-computed)
              - 뉴스 피드를 읽는 데 드는 시간이 짧아짐
          - **단점**
              - 친구가 많은 사용자의 경우
                  - 친구 목록을 가져오고 그 모두의 뉴스 피드를 갱신하는 데 많은 시간이 소요
                  - 핫키(Hotkey) 문제
              - 서비스를 자주 이용하지 않은 사용자의 피드까지 갱신
              - 컴퓨팅 자원 낭비
      - 2️⃣ **읽기 시점에 팬아웃하는 모델(Fanout-on-Read)**
          - **풀(Pull) 모델**
          - **동작 원리**
              - 피드를 읽어야 하는 시점에 뉴스 피드를 갱신
              - 요청 기반(On-demand) 모델
              - 사용자가 본인 홈페이지나 타임 라인을 로딩하는 시점에 새로운 포스트를 가져옴
          - **장점**
              - 비활성화된 사용자, 거의 로그인하지 않는 사용자의 경우 유리한 모델
              - 로그인하기 전까지는 어떤 컴퓨팅 자원도 소모하지 않음
              - 데이터를 친구 각각에 푸시하는 작업이 필요 없으므로 핫키(Hotkey)문제 없음
          - **단점**
              - 뉴스 피드를 읽는 데 많은 시간이 소요될 수 있음
  
  ### 본 설계안
  
  - **쓰기 시점 & 읽기 시점 팬아웃 모델을 결합**
      - 대부분의 사용자의 경우, 뉴스 피드를 빠르게 가져오는 것이 중요 : **Push 모델**
      - 친구나 팔로워(Follower)가 아주 많은 사용자의 경우, 과부하 방지 : **Pull 모델**
  - **안정 해시(Consistent Hashing)를 통해 요청과 데이터 분산**
      - 핫키(Hotkey) 문제를 줄임
      
    <img src="https://github.com/user-attachments/assets/68a39173-ecea-4575-88c4-552a50a622fe" width="400px"/>

  - **팬아웃 서비스 동작**
      - **1️⃣ 그래프 DB에서 친구 ID 목록을 가져옴**
          - 친구 관계나 친구 추천을 관리하기 적합
      - **2️⃣ 사용자 정보 캐시에서 친구들의 정보를 가져옴**
          - 사용자 설정에 따라 친구 가운데 일부를 걸러냄
          - ex) 무시(mute) 설정, 일부에게만 공개된 포스팅
      - **3️⃣ 친구 목록과 새 스토리의 포스팅 ID를 MQ에 넣음**
      - **4️⃣ 팬아웃 작업 서버가 MQ에서 데이터를 꺼내 뉴스 피드 데이터를 뉴스 피드 캐시에 넣음**
          - **뉴스 피드 캐시**
              - `<포스팅ID, 사용자ID>` 매핑 테이블
              - 사용자 정보와 포스팅 정보 전체를 저장하는 것은 메모리 요구량이 너무 많음
              - 캐시 크기 제한, 최신 스토리를 주로 조회하기 때문에 **Cache Miss 확률 낮음**
              
            <img src="https://github.com/user-attachments/assets/3bce047c-e959-4942-a6c3-8f41c5865c08" width="200px"/>

  
  ### 피드 읽기 흐름 상세 설계
  
  <img src="https://github.com/user-attachments/assets/816219e3-82f2-430e-982a-92c84fec3da9" width="400px"/>

  - 이미지, 비디오와 같은 **미디어 콘텐츠는 CDN에 저장**하여 빨리 읽을 수 있도록 함
  - **클라이언트가 뉴스 피드를 읽는 과정**
      - 1️⃣ 사용자가 뉴스 피드를 읽으려는 요청을 전송
          - `GET /v1/me/feed`
      - **2️⃣ 로드밸런서가 요청을 웹 서버 가운데 하나로 전달**
      - **3️⃣ 웹 서버는 피드를 가져오기 위해 뉴스 피드 서비스를 호출**
      - **4️⃣ 뉴스 피드 서비스는 뉴스 피드 캐시에 포스팅 ID 목록을 가져온다**
      - **5️⃣ 표시할 데이터를 사용자 캐시와 포스팅 캐시에서 가져와 완전한 뉴스 피드 생성**
          - 사용자 이름
          - 사용자 사진
          - 포스팅 콘텐츠
          - 이미지
      - **6️⃣ 생성된 뉴스 피드를 JSON 형태로 클라이언트에 전송**
          - 클라이언트는 해당 피드를 렌더링
  
  ### 캐시 구조
  
  <img src="https://github.com/user-attachments/assets/370932ec-49f5-4429-a5cc-f88af21f0cc0" width="400px"/>

  - **1️⃣ 뉴스 피드**
      - 뉴스 피드의 ID를 보관
  - **2️⃣ 콘텐츠**
      - 포스팅 데이터를 보관
      - 인기 콘텐츠는 따로 보관
  - **3️⃣ 소셜 그래프**
      - 사용자 간 관계 정보를 보관
  - **4️⃣ 행동(Action)**
      - 포스팅에 대한 사용자의 행위에 관한 정보를 보관
      - 포스팅에 대한 좋아요, 답글 등이 포함
  - **5️⃣ 횟수(Counter)**
      - 좋아요 횟수
      - 응답 수
      - 팔로워 수
      - 팔로잉 수
  
  ---
  
</details>
<details>
  <summary><b>마무리</b></summary>
  
  ---
  
  ## 4단계: 마무리
  
  ### 뉴스 피드 시스템
  
  - **구성**
      - 뉴스 피드 발생
      - 뉴스 피드 생성
  - **고려 사항**
      - 타협적 결정(Trade-off)
      - 규모 확장성
      
  
  ### 데이터베이스 규모 확장
  
  - 수직적 규모 확장 vs 수평적 규모 확장
  - SQL vs NoSQL
  - 주-부(Master-Slave) 다중화
  - 복제본(Replica)에 대한 읽기 연산
  - 일관성 모델(Consistency Model)
  - 데이터베이스 샤딩(Sharding)
  
  ### 추가 고려사항
  
  - 웹 게층(Web tier)를 무상태로 운영하기
  - 가능한 한 많은 데이터를 캐시할 방법
  - 여러 데이터 센터를 지원할 방법
  - MQ를 사용하여 컴포넌트 사이의 결합도 낮추기
  - 핵심 메트릭(Key Matric)에 대한 모니터링,
      - 트래픽이 몰리는 시간대의 QPS(Quries per Second)
      - 사용자가 뉴스 피드를 새로고침(Refresh) 할 때의 지연시간
      
  
  ---

</details>
